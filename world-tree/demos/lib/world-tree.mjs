var be=Object.defineProperty;var ye=(h,t,e)=>t in h?be(h,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):h[t]=e;var v=(h,t,e)=>(ye(h,typeof t!="symbol"?t+"":t,e),e);var fe=(r=>(r[r.Colinear=0]="Colinear",r[r.Clockwise=1]="Clockwise",r[r.CounterClockwise=2]="CounterClockwise",r))(fe||{}),C=class{constructor(t,e){this._x=t;this._y=e;Object.freeze(this)}get x(){return this._x}get y(){return this._y}dot(t){let e=this.x*t.x,r=this.y*t.y;return e+r}mag(){return Math.sqrt(this.dot(this))}normalise(){let t=this.mag(),e=this.x/t,r=this.y/t;return new C(e,r)}angle(t){let e=this.x*t.y-t.x*this.y,r=this.dot(t);return Math.atan2(e,r)}},_=class{constructor(t,e){this._x=t;this._y=e;Object.freeze(this)}get x(){return this._x}get y(){return this._y}add(t){return new _(this.x+t.x,this.y+t.y)}sub(t){return new _(this.x-t.x,this.y-t.y)}diff(t){return new C(this.x-t.x,this.y-t.y)}static orientation(t,e,r){let n=(e.y-t.y)*(r.x-e.x)-(e.x-t.x)*(r.y-e.y);return n==0?0:n>0?1:2}},rt=class{constructor(t,e){this._p0=t;this._p1=e}get p0(){return this._p0}get p1(){return this._p1}contains(t){return t.x<=Math.max(this.p0.x,this.p1.x)&&t.x>=Math.min(this.p0.x,this.p1.x)&&t.y<=Math.max(this.p0.y,this.p1.y)&&t.y>=Math.min(this.p0.y,this.p1.y)}add(t){let e=this.p0.add(t),r=this.p1.add(t);return new rt(e,r)}on(t){let e=t.x-this.p0.x,r=t.y-this.p0.y,n=this.p1.x-this.p0.x,s=this.p1.y-this.p0.y;return e*s-r*n==0}intersects(t){if(this.on(t.p0)||this.on(t.p1))return!1;let e=_.orientation(this.p0,this.p1,t.p0),r=_.orientation(this.p0,this.p1,t.p1),n=_.orientation(t.p0,t.p1,this.p0),s=_.orientation(t.p0,t.p1,this.p1);return!!(e!=r&&n!=s||e==0&&this.contains(t.p0)||r==0&&this.contains(t.p1)||n==0&&t.contains(this.p0)||s==0&&t.contains(this.p1))}distance(t){let e=this.p0.x*this.p1.y-this.p1.x*this.p0.y,r=this.p0.x*t.y-t.x*this.p0.y,n=1/Math.sqrt(Math.pow(this.p1.x-this.p0.x,2)+Math.pow(this.p1.y-this.p0.y,2));return e*r*n}},w=class{constructor(t,e,r){this._x=t;this._y=e;this._z=r;Object.freeze(this)}get x(){return this._x}get y(){return this._y}get z(){return this._z}add(t){return new w(this.x+t.x,this.y+t.y,this.z+t.z)}mul(t){return new w(this.x*t.x,this.y*t.y,this.z*t.z)}addScalar(t){return new w(this.x+t,this.y+t,this.z+t)}sub(t){return new w(this.x-t.x,this.y-t.y,this.z-t.z)}vec_diff(t){return new P(this.x-t.x,this.y-t.y,this.z-t.z)}isSameAsRounded(t){return Math.round(this.x)==Math.round(t.x)&&Math.round(this.y)==Math.round(t.y)&&Math.round(this.z)==Math.round(t.z)}isSameAs(t){return this.x===t.x&&this.y===t.y&&this.z===t.z}},P=class{constructor(t,e,r){this._x=t;this._y=e;this._z=r;Object.freeze(this)}get x(){return this._x}get y(){return this._y}get z(){return this._z}get zero(){return this.x===0&&this.y===0&&this.z===0}get asString(){return"(x, y, z) = ("+this.x+", "+this.y+", "+this.z+")"}add(t){let e=this.x+t.x,r=this.y+t.y,n=this.z+t.z;return new P(e,r,n)}mulScalar(t){let e=this.x*t,r=this.y*t,n=this.z*t;return new P(e,r,n)}dot(t){let e=this.x*t.x,r=this.y*t.y,n=this.z*t.z;return e+r+n}mag(){return Math.sqrt(this.dot(this))}norm(){let t=this.mag(),e=this.x/t,r=this.y/t,n=this.z/t;return new P(e,r,n)}cross(t){let e=this.y*t.z-this.z*t.y,r=this.z*t.x-this.x*t.z,n=this.x*t.y-this.y*t.x;return new P(e,r,n)}angle(t){let e=this.cross(t).mag(),r=this.dot(t);return Math.atan2(e,r)}absMin(t){let e=Math.abs(this.x)<Math.abs(t.x)?this.x:t.x,r=Math.abs(this.y)<Math.abs(t.y)?this.y:t.y,n=Math.abs(this.z)<Math.abs(t.z)?this.z:t.z;return new P(e,r,n)}equal(t){return this.x==t.x&&this.y==t.y&&this.z==t.z}},f=class{constructor(t,e,r){this._point=t;this._u=e.vec_diff(t),this._v=r.vec_diff(t),this._normal=this.u.cross(this.v)}_normal;_v;_u;get point(){return this._point}get normal(){return this._normal}get u(){return this._u}get v(){return this._v}transform(t){this._point=this.point.add(t)}get asString(){return"normal = "+this.normal.asString+", u = "+this.u.asString+", v = "+this.u.asString}distance(t){let e=-this.normal.dot(t.vec_diff(this.point)),r=this.normal.dot(this.normal),n=e/r,s=t.addScalar(n).mul(this.normal);return t.vec_diff(s).mag()}intersects(t,e){let r=e.vec_diff(t),n=t.vec_diff(this.point),s=-this.normal.dot(n),i=this.normal.dot(r);if(Math.abs(i)<.01)return null;let o=s/i;return o<0||o>1?null:t.add(r.mulScalar(o))}},nt=class{constructor(t){this._vertex=t}get vertex(){return this._vertex}get plane(){return this._vertex}intersectsPlane(t,e){return this.plane.intersects(t,e)}},L=class extends nt{_uDotv;_uDotu;_vDotv;_denominator;constructor(t){super(t);let e=this.vertex.u,r=this.vertex.v;this._uDotv=e.dot(r),this._uDotu=e.dot(e),this._vDotv=r.dot(r),this._denominator=1/(Math.pow(this._uDotv,2)-this._uDotu*this._vDotv)}vertices(){return[this.vertex]}transform(t){this.vertex.transform(t)}intersects(t){let e=t.vec_diff(this.vertex.point),r=this.vertex.u,n=this.vertex.v,s=e.dot(n),i=e.dot(r),o=(this._uDotv*s-this._vDotv*i)*this._denominator,c=(this._uDotv*i-this._uDotu*s)*this._denominator;return o>=0&&c>=0&&o+c<=1}},T=class extends nt{_triangleA;_triangleB;constructor(t,e){if(super(t),!t.normal.equal(e.normal))throw"Expected QuadFace3D vertices to have equilavent normals";this._triangleA=new L(t),this._triangleB=new L(e)}vertices(){return[this._triangleA.vertex,this._triangleB.vertex]}transform(t){this._triangleA.transform(t),this._triangleB.transform(t)}intersects(t){return this._triangleA.intersects(t)||this._triangleB.intersects(t)}},Nt=class{constructor(t,e,r,n,s){this._face=t;this._begin=e;this._end=r;this._i=n;this._theta=s}get face(){return this._face}get begin(){return this._begin}get end(){return this._end}get i(){return this._i}get theta(){return this._theta}},B=class{constructor(t){this._bounds=t;this._widthVec3D=new P(t.width,0,0),this._depthVec3D=new P(0,t.depth,0),this._heightVec3D=new P(0,0,t.height)}_faces=new Array;_intersectInfo;_widthVec3D;_depthVec3D;_heightVec3D;_name;_cuboid=!1;get bounds(){return this._bounds}get widthVec3D(){return this._widthVec3D}get depthVec3D(){return this._depthVec3D}get heightVec3D(){return this._heightVec3D}get intersectInfo(){return this._intersectInfo}get name(){return this._name}get cuboid(){return this._cuboid}transform(t){for(let e of this._faces)e.transform(t)}obstructsRay(t,e){for(let r of this._faces){let n=r.intersectsPlane(t,e);if(n!=null&&r.intersects(n)){let s=n.vec_diff(t),i=r.plane.normal,o=s.angle(i);return new Nt(r,t,e,n,o)}}return null}},jt=class extends B{constructor(t){super(t),this._name="NoGeometry"}obstructs(t,e){return null}},it=class extends B{constructor(t){super(t),this._name="CuboidGeometry",this._cuboid=!0;let e=[this.bounds.minLocation,this.bounds.minLocation.add(this.heightVec3D),this.bounds.minLocation.add(this.depthVec3D),this.bounds.minLocation.add(this.widthVec3D),this.bounds.maxLocation.sub(this.heightVec3D),this.bounds.maxLocation.sub(this.depthVec3D),this.bounds.maxLocation.sub(this.widthVec3D),this.bounds.maxLocation],r=new f(e[2],e[6],e[0]),n=new f(e[1],e[0],e[6]);this._faces.push(new T(r,n));let s=new f(e[4],e[7],e[2]),i=new f(e[6],e[2],e[7]);this._faces.push(new T(s,i));let o=new f(e[3],e[5],e[4]),c=new f(e[7],e[4],e[5]);this._faces.push(new T(o,c));let a=new f(e[5],e[1],e[7]),u=new f(e[6],e[7],e[1]);this._faces.push(new T(a,u));let y=new f(e[0],e[3],e[2]),b=new f(e[4],e[2],e[3]);this._faces.push(new T(y,b));let l=new f(e[0],e[1],e[3]),p=new f(e[5],e[3],e[1]);this._faces.push(new T(l,p))}},st=class extends B{constructor(t){super(t),this._name="RampUpWestGeometry";let e=[this.bounds.minLocation,this.bounds.minLocation.add(this.depthVec3D),this.bounds.minLocation.add(this.widthVec3D),this.bounds.maxLocation.sub(this.heightVec3D),this.bounds.minLocation.add(this.heightVec3D),this.bounds.maxLocation.sub(this.widthVec3D)],r=new f(e[1],e[5],e[0]),n=new f(e[4],e[0],e[5]);this._faces.push(new T(r,n)),this._faces.push(new L(new f(e[1],e[3],e[5])));let s=new f(e[2],e[4],e[3]),i=new f(e[5],e[3],e[4]);this._faces.push(new T(s,i));let o=new f(e[3],e[1],e[2]),c=new f(e[0],e[2],e[1]);this._faces.push(new T(o,c)),this._faces.push(new L(new f(e[0],e[4],e[2])))}},ot=class extends B{constructor(t){super(t),this._name="RampUpEastGeometry";let e=[this.bounds.minLocation,this.bounds.minLocation.add(this.depthVec3D),this.bounds.minLocation.add(this.widthVec3D),this.bounds.maxLocation.sub(this.heightVec3D),this.bounds.maxLocation.sub(this.depthVec3D),this.bounds.maxLocation],r=new f(e[1],e[5],e[0]),n=new f(e[4],e[0],e[5]),s=new T(r,n);this._faces.push(s);let i=new L(new f(e[3],e[5],e[1]));this._faces.push(i);let o=new f(e[2],e[4],e[3]),c=new f(e[5],e[3],e[4]),a=new T(o,c);this._faces.push(a);let u=new f(e[1],e[0],e[3]),y=new f(e[2],e[3],e[0]),b=new T(u,y);this._faces.push(b);let l=new L(new f(e[4],e[2],e[0]));this._faces.push(l)}},at=class extends B{constructor(t){super(t),this._name="RampUpNorthGeometry";let e=[this.bounds.minLocation,this.bounds.minLocation.add(this.depthVec3D),this.bounds.minLocation.add(this.heightVec3D),this.bounds.maxLocation.sub(this.depthVec3D),this.bounds.maxLocation.sub(this.heightVec3D),this.bounds.minLocation.add(this.widthVec3D)],r=new L(new f(e[0],e[1],e[2]));this._faces.push(r);let n=new f(e[1],e[4],e[2]),s=new f(e[3],e[2],e[4]),i=new T(n,s);this._faces.push(i);let o=new L(new f(e[5],e[3],e[4]));this._faces.push(o);let c=new f(e[0],e[2],e[5]),a=new f(e[3],e[5],e[2]),u=new T(c,a);this._faces.push(u);let y=new f(e[1],e[4],e[0]),b=new f(e[5],e[0],e[4]),l=new T(y,b);this._faces.push(l)}},ht=class extends B{constructor(t){super(t),this._name="RampUpSouthGeometry";let e=[this.bounds.minLocation,this.bounds.minLocation.add(this.depthVec3D),this.bounds.maxLocation.sub(this.widthVec3D),this.bounds.maxLocation,this.bounds.maxLocation.sub(this.heightVec3D),this.bounds.minLocation.add(this.widthVec3D)],r=new L(new f(e[0],e[1],e[2]));this._faces.push(r);let n=new f(e[1],e[4],e[2]),s=new f(e[3],e[2],e[4]),i=new T(n,s);this._faces.push(i);let o=new L(new f(e[5],e[3],e[4]));this._faces.push(o);let c=new f(e[0],e[2],e[5]),a=new f(e[3],e[5],e[2]),u=new T(c,a);this._faces.push(u);let y=new f(e[1],e[4],e[0]),b=new f(e[5],e[0],e[4]),l=new T(y,b);this._faces.push(l)}};var j=(a=>(a[a.North=0]="North",a[a.NorthEast=1]="NorthEast",a[a.East=2]="East",a[a.SouthEast=3]="SouthEast",a[a.South=4]="South",a[a.SouthWest=5]="SouthWest",a[a.West=6]="West",a[a.NorthWest=7]="NorthWest",a[a.Max=8]="Max",a))(j||{}),E=class{static getDirectionName(t){switch(t){default:break;case 0:return"north";case 1:return"north east";case 2:return"east";case 3:return"south east";case 4:return"south";case 5:return"south west";case 6:return"west";case 7:return"north west"}return console.error("unhandled direction when getting name:",t),"error"}static getAdjacentCoord(t,e){let r=this.neighbourOffsets.get(e);return t.add(r)}static getDirectionFromPoints(t,e){return this.getDirectionFromVector(e.diff(t))}static getDirectionFromVector(t){let e=t.mag(),n=180*new C(0,-e).angle(t)/Math.PI+22.5;return n<0&&(n=180+(180+n)),Math.floor(n/45)}static getOppositeDirection(t){return(t+8/2)%8}static getAdjacentDirections(t){let e=(t+8-1)%8,r=(t+1)%8;return[e,r]}};v(E,"neighbourOffsets",new Map([[0,new C(0,-1)],[2,new C(1,0)],[4,new C(0,1)],[6,new C(-1,0)],[7,new C(-1,-1)],[1,new C(1,-1)],[3,new C(1,1)],[5,new C(-1,1)]]));var We={loaded:!0,addBitmap:function(h,t,e,r,n){}};var Gt=class{static add(t){this._sheets.push(t)}static reset(){this._sheets=new Array}_image;_canvas;_context2D;_canvasBlob;_renderer;_loaded=!1;_bitmapsToLoad=new Array;constructor(t){this._renderer=t.renderer,this._image=new Image}async generateBlob(){this.canvas=new OffscreenCanvas(this.width,this.height),this.context2D=this.canvas.getContext("2d",{willReadFrequently:!0}),this.context2D.drawImage(this.image,0,0,this.width,this.height),await this.canvas.convertToBlob().then(t=>{this.canvasBlob=t},t=>{console.log("failed to convert to blob:",t)}),this.loaded=!0}static load(t,e){return new Promise((r,n)=>{t.image.onload=()=>r(t.generateBlob()),t.image.src=e+".png"})}static async create(t,e){let r=new Gt(e);return await this.load(r,t),this.add(r),r}get image(){return this._image}get width(){return this._image.width}get height(){return this._image.height}get name(){return this._image.src}get loaded(){return this._loaded}set loaded(t){console.log("loaded spritesheet:",this.image.src),this._loaded=t}get canvas(){return this._canvas}set canvas(t){this._canvas=t}get context2D(){return this._context2D}set context2D(t){this._context2D=t}get canvasBlob(){return this._canvasBlob}set canvasBlob(t){this._canvasBlob=t}get bitmapsToLoad(){return this._bitmapsToLoad}isTransparentAt(t,e){return this.context2D.getImageData(t,e,1,1).data[3]==0}async addBitmap(t,e,r,n,s){console.assert(this.loaded,"sheet not loaded!"),createImageBitmap(this.canvasBlob,e,r,n,s).then(i=>{this._renderer.addBitmap(t,i)},i=>{console.log("failed to createImageBitmap:",i)})}},U=Gt;v(U,"_sheets",new Array);var ut=class{constructor(t,e,r,n,s){this._sheet=t;this._width=n;this._height=s;this._offset=new _(e,r),console.assert(this.offset.x>=0,"offset.x < 0"),console.assert(this.offset.y>=0,"offset.y < 0");let i=new _(this.offset.x+this.width,this.offset.y+this.height);this._id=ut.sprites.length}_id;_offset;static create(t,e,r,n,s){console.assert(t.loaded,"sheet is not loaded yet!");let i=new ut(t,e,r,n,s);return this.sprites.push(i),t.addBitmap(i.id,i.offset.x,i.offset.y,i.width,i.height),i.id}isTransparentAt(t,e){return t+=this.offset.x,e+=this.offset.y,this.sheet.isTransparentAt(t,e)}get sheet(){return this._sheet}get id(){return this._id}get width(){return this._width}get height(){return this._height}get offset(){return this._offset}},z=ut;v(z,"sprites",new Array);var $t=(r=>(r[r.AddCanvas=0]="AddCanvas",r[r.AddSprite=1]="AddSprite",r[r.Draw=2]="Draw",r))($t||{}),Zt=class{constructor(t,e){this._spriteId=t;this._coord=e;Object.freeze(this)}get spriteId(){return this._spriteId}get coord(){return this._coord}},V=class{constructor(t){this._currentSpriteId=t}isTransparentAt(t,e){return z.sprites[this._currentSpriteId].isTransparentAt(t,e)}get width(){return z.sprites[this._currentSpriteId].width}get height(){return z.sprites[this._currentSpriteId].height}},qt=class extends V{constructor(e,r){super(0);this._width=e;this._height=r}get width(){return this._width}get height(){return this._height}update(){return 0}},$=class extends V{constructor(t){super(t)}update(){return this._currentSpriteId}},ct=class extends V{constructor(e,r){super(e[0].id);this._interval=r;for(let n in e)this._spriteIds.push(e[n].id);this._nextUpdate=Date.now()+r}_nextUpdate=0;_currentSpriteIdx=0;_spriteIds=new Array;update(){return this._spriteIds[this._currentSpriteIdx]}get firstId(){return this._spriteIds[0]}get lastId(){return this._spriteIds[this._spriteIds.length-1]}get currentSpriteId(){return console.assert(this._currentSpriteIdx>=0),console.assert(this._currentSpriteIdx<this._spriteIds.length),this._spriteIds[this._currentSpriteIdx]}},Qt=class extends ct{_increase=!0;constructor(t,e){super(t,e),this._currentSpriteIdx=Math.floor(Math.random()*(this._spriteIds.length-1))}update(){return this._nextUpdate>Date.now()?this.currentSpriteId:(this._currentSpriteIdx==this._spriteIds.length-1?this._increase=!1:this._currentSpriteIdx==0&&(this._increase=!0),this._increase?this._currentSpriteIdx++:this._currentSpriteIdx--,this._nextUpdate=Date.now()+this._interval,this.currentSpriteId)}},Kt=class extends ct{constructor(t,e){super(t,e),this._currentSpriteIdx=0}update(){return this._nextUpdate>Date.now()?this.currentSpriteId:(this._currentSpriteIdx=(this._currentSpriteIdx+1)%this._spriteIds.length,this._nextUpdate=Date.now()+this._interval,this.currentSpriteId)}},Ft=class extends V{constructor(e){super(0);this._staticGraphics=e}_direction=0;get direction(){return this._direction}set direction(e){if(this._staticGraphics.has(e))this._direction=e;else{let r=E.getAdjacentDirections(e);this._staticGraphics.has(r[0])?this._direction=r[0]:this._staticGraphics.has(r[1])&&(this._direction=r[1]),console.log("graphic direction unsupported")}}update(){return this._staticGraphics.has(this.direction)?this._staticGraphics.get(this.direction).update():(console.error("unhandled stationary graphic:",E.getDirectionName(this.direction)),0)}};async function Be(h,t){let e=function(n){let s=new Map;for(let i=0;i<h.numFrames;++i)for(let o=0;o<h.columns.length;++o){let c=h.columns[o],a=z.create(n,o*h.spriteWidth,i*h.spriteHeight,h.spriteWidth,h.spriteHeight),u=new $(a);s.set(c,u)}return new Ft(s)};if(Object.hasOwn(h,"spriteSheet"))return e(h.spriteSheet);if(!Object.hasOwn(h,"spriteSheetName"))throw new Error("expected spriteSheetName");return await U.create(h.spriteSheetName,t).then(n=>e(n))}var Jt=class extends V{constructor(e,r){super(0);this._staticGraphics=e;this._movementGraphics=r}_stationary=!0;_direction=0;get stationary(){return this._stationary}set stationary(e){this._stationary=e}get direction(){return this._direction}set direction(e){this._staticGraphics.has(e)&&this._movementGraphics.has(e)?this._direction=e:console.log("graphic direction unsupported")}update(){return!this.stationary&&this._movementGraphics.has(this.direction)?this._movementGraphics.get(this.direction).update():this.stationary&&this._staticGraphics.has(this.direction)?this._staticGraphics.get(this.direction).update():(this.stationary?console.error("unhandled stationary graphic:",E.getDirectionName(this.direction)):console.error("unhandled movement graphic:",E.getDirectionName(this.direction)),0)}};var dt=class{constructor(t,e){this._array=t;this._length=e}get array(){return this._array}get buffer(){return this._array.buffer}get length(){return this._length}},lt=class{addBitmap(t,e){}draw(t){}},te=class{constructor(t,e){this._width=t;this._height=e;this._canvas=new OffscreenCanvas(t,e),this._ctx=this._canvas.getContext("2d")}_ctx;_bitmaps=new Array;_canvas;get bitmaps(){return this._bitmaps}addBitmap(t,e){t>=this.bitmaps.length&&(this.bitmaps.length=t+1),this.bitmaps[t]=e}draw(t){this._ctx.clearRect(0,0,this._width,this._height);let e=t.array;for(let r=0;r<t.length-2;r+=3){let n=e[r],s=e[r+1],i=e[r+2];console.assert(n<this.bitmaps.length,"bitmap length mismatch"),this._ctx.drawImage(this.bitmaps[n],s,i)}}},pt=class{constructor(t){this._canvas=t;if(this._width=this.canvas.width,this._height=this.canvas.height,window.Worker){let e=this.canvas.transferControlToOffscreen(),r=window.URL.createObjectURL(this.workerBlob_);this._worker=new Worker(r),this.worker.postMessage({type:0,canvas:e,width:this.width,height:this.height},[e])}else this._ctx=this.canvas.getContext("2d")}_worker;_ctx;_bitmaps=new Array;_width;_height;workerBlob_=new Blob([`
    const ctx = {};
    ctx.sprites = new Array();
    ctx.valid = false;

    onmessage = function(e) {
    switch (e.data.type) {
      default:
        console.error('unhandled graphic event');
        break;
      case 0: //GraphicEvent.AddCanvas:
        ctx.width = e.data.width;
        ctx.height = e.data.height;
        ctx.canvas = e.data.canvas;
        break;
      case 1: { //GraphicEvent.AddSprite:
        const id = e.data.id;
        const sprite = e.data.sprite
        if (id == ctx.sprites.length) {
          ctx.sprites.push(sprite);
        } else if (id < ctx.sprites.length) {
          ctx.sprites[id] = sprite;
        } else {
          for (let i = ctx.sprites.length; i < id; ++i) {
            ctx.sprites.push(0);
          }
          ctx.sprites.push(sprite);
        }
        ctx.valid = false;
        break;
      }
      case 2: { //GraphicEvent.Draw:
        if (ctx.canvas == undefined) break;

        const nodes = new Int16Array(e.data.buffer);
        if (!ctx.valid) {
          for (let i = 0; i < e.data.length; i += 3) {
            const spriteId = nodes[i];
            if (spriteId >= ctx.sprites.length) return;
            if (typeof ctx.sprites[spriteId] === "number") return;
          }
          ctx.valid = true;
        }

        const ctx2d = ctx.canvas.getContext("2d");
        ctx2d.clearRect(0, 0, ctx.width, ctx.height);
        for (let i = 0; i < e.data.length; i += 3) {
          const spriteId = nodes[i];
          const x =  nodes[i+1];
          const y = nodes[i+2];
          ctx2d.drawImage(ctx.sprites[spriteId], x, y);
        }
        break;
      }
    }
  }`]);get width(){return this._width}get height(){return this._height}get canvas(){return this._canvas}get ctx(){return this._ctx}get bitmaps(){return this._bitmaps}get worker(){return this._worker}addBitmap(t,e){window.Worker?this.worker.postMessage({type:1,id:t,sprite:e},[e]):(t>=this.bitmaps.length&&(this.bitmaps.length=t+1),this.bitmaps[t]=e)}draw(t){if(window.Worker)this.worker.postMessage({type:2,buffer:t.buffer,length:t.length},[t.buffer]);else{this.ctx.clearRect(0,0,this.width,this.height),console.assert(t.length%3==0,"elements not mod 3");let e=t.array;for(let r=0;r<t.length-2;r+=3){let n=e[r],s=e[r+1],i=e[r+2];n>=this.bitmaps.length||(console.assert(n<this.bitmaps.length,"bitmap length mismatch",n),this.ctx.drawImage(this.bitmaps[n],s,i))}}}};var Rt=class{constructor(t,e){this._element=t;this._key=e}get element(){return this._element}get key(){return this._key}set key(t){this._key=t}},mt=class{_items=new Array;_indices=new Map;constructor(){}get indices(){return this._indices}get items(){return this._items}get size(){return this.items.length-1}get length(){return this.items.length}empty(){return this.length==0}pop(){let t=this.items[0];this.items.splice(0,1),this.indices.delete(t.element);for(let e=0;e<this.items.length;++e){let r=this.items[e];this.indices.set(r.element,e)}return this.build(),t.element}parentIdx(t){return t-1>>1}leftIdx(t){return 2*t+1}rightIdx(t){return 2*t+2}keyAt(t){return console.assert(t<this.length),this.items[t].key}insert(t,e){console.assert(!this.indices.has(t)),this.items.push(new Rt(t,Number.MAX_VALUE)),this.indices.set(t,this.size),this.setKey(t,e)}setKey(t,e){console.assert(this.indices.has(t));let r=this.indices.get(t);console.assert(r<this.length);let n=this.items[r];for(console.assert(e<=n.key),n.key=e;r>0&&this.keyAt(this.parentIdx(r))>this.keyAt(r);)this.exchange(r,this.parentIdx(r)),r=this.parentIdx(r)}exchange(t,e){console.assert(t<this.length),console.assert(e<this.length);let r=this.items[t],n=this.items[e];this.items[t]=n,this.items[e]=r,this.indices.set(r.element,e),this.indices.set(n.element,t)}build(){for(let t=this.size>>1;t>=0;t--)this.heapify(t)}heapify(t){let e=this.leftIdx(t),r=this.rightIdx(t),n=t;e<this.length&&this.keyAt(e)<this.keyAt(t)&&(n=e),r<this.length&&this.keyAt(r)<this.keyAt(t)&&(n=r),n!=t&&(this.exchange(t,n),this.heapify(n))}};var q=(s=>(s.Moving="moving",s.EndMove="endMove",s.FaceDirection="faceDirection",s.Collision="collision",s.NoCollision="noCollision",s))(q||{}),kt=(t=>(t.CameraMove="cameraMove",t))(kt||{}),Z=class{_listeners=new Map;_events=new Set;constructor(){}post(t){this._events.add(t)}service(){for(let t of this._events){if(!this._listeners.has(t))continue;let e=this._listeners.get(t);for(let r of e)r()}this._events.clear()}addEventListener(t,e){if(!this._listeners.has(t))this._listeners.set(t,new Array);else{let r=this._listeners.get(t);for(let n in r)if(r[n]===e)return}this._listeners.get(t).push(e)}removeEventListener(t,e){if(!this._listeners.has(t))return;let r=this._listeners.get(t),n=r.indexOf(e,0);n>-1&&r.splice(n,1)}},bt=class{_callbacks=new Array;constructor(){}add(t){this._callbacks.push(t)}service(){for(let t=this._callbacks.length-1;t>=0;t--)this._callbacks[t]()&&this._callbacks.splice(t,1)}};var F=class{constructor(t,e,r){this._width=t;this._depth=e;this._height=r}get width(){return this._width}get depth(){return this._depth}get height(){return this._height}log(){console.log(" - (WxDxH):",this.width,this.depth,this.height)}},M=class{constructor(t,e){this._centre=t;this._dimensions=e;this.centre=t}_minLocation;_maxLocation;_bottomCentre;_topCentre;get minLocation(){return this._minLocation}get minX(){return this.minLocation.x}get minY(){return this.minLocation.y}get minZ(){return this.minLocation.z}get maxLocation(){return this._maxLocation}get maxX(){return this.maxLocation.x}get maxY(){return this.maxLocation.y}get maxZ(){return this.maxLocation.z}get bottomCentre(){return this._bottomCentre}get topCentre(){return this._topCentre}get width(){return this._dimensions.width}get depth(){return this._dimensions.depth}get height(){return this._dimensions.height}get dimensions(){return this._dimensions}get centre(){return this._centre}set centre(t){this._centre=t;let e=this.width/2,r=this.depth/2,n=this.height/2,s=t.x-e,i=t.y-r,o=t.z-n;this._bottomCentre=new w(t.x,t.y,o),this._topCentre=new w(t.x,t.y,t.z+n),this._minLocation=new w(s,i,o),s=t.x+e,i=t.y+r,o=t.z+n,this._maxLocation=new w(s,i,o)}update(t){this._centre=this._centre.add(t),this._bottomCentre=this._bottomCentre.add(t),this._minLocation=this._minLocation.add(t),this._maxLocation=this._maxLocation.add(t)}futureBounds(t){let e=new M(this.centre,this.dimensions);return e.update(t),e}contains(t){return!(t.x<this._minLocation.x||t.y<this._minLocation.y||t.z<this._minLocation.z||t.x>this._maxLocation.x||t.y>this._maxLocation.y||t.z>this._maxLocation.z)}containsBounds(t){return this.contains(t.minLocation)&&this.contains(t.maxLocation)}intersects(t){return!(t.minLocation.x>this.maxLocation.x||t.maxLocation.x<this.minLocation.x||t.minLocation.y>this.maxLocation.y||t.maxLocation.y<this.minLocation.y||t.minLocation.z>this.maxLocation.z||t.maxLocation.z<this.minLocation.z)}axisOverlapX(t){return t.minLocation.x>=this.minLocation.x&&t.minLocation.x<=this.maxLocation.x||t.maxLocation.x>=this.minLocation.x&&t.maxLocation.x<=this.maxLocation.x}axisOverlapY(t){return t.minLocation.y>=this.minLocation.y&&t.minLocation.y<=this.maxLocation.y||t.maxLocation.y>=this.minLocation.y&&t.maxLocation.y<=this.maxLocation.y}axisOverlapZ(t){return t.minLocation.z>=this.minLocation.z&&t.minLocation.z<=this.maxLocation.z||t.maxLocation.z>=this.minLocation.z&&t.maxLocation.z<=this.maxLocation.z}insert(t){if(this.containsBounds(t))return;let e=t.minLocation.x<this.minLocation.x?t.minLocation.x:this.minLocation.x,r=t.minLocation.y<this.minLocation.y?t.minLocation.y:this.minLocation.y,n=t.minLocation.z<this.minLocation.z?t.minLocation.z:this.minLocation.z,s=t.maxLocation.x>this.maxLocation.x?t.maxLocation.x:this.maxLocation.x,i=t.maxLocation.y>this.maxLocation.y?t.maxLocation.y:this.maxLocation.y,o=t.maxLocation.z>this.maxLocation.z?t.maxLocation.z:this.maxLocation.z;this._dimensions=new F(s-e,i-r,o-n);let c=new w(e,r,n),a=new w(s,i,o),u=(a.x-c.x)/2,y=(a.y-c.y)/2,b=(a.z-c.z)/2;this._centre=new w(c.x+u,c.y+y,c.z+b),this._minLocation=c,this._maxLocation=a}dump(){console.log("BoundingCuboid"),console.log(" - min (x,y,z):",this.minLocation.x,this.minLocation.y,this.minLocation.z),console.log(" - max (x,y,z):",this.maxLocation.x,this.maxLocation.y,this.maxLocation.z),console.log(" - centre (x,y,z):",this.centre.x,this.centre.y,this.centre.z),console.log(" - dimensions (WxDxH):",this.width,this.depth,this.height)}},yt=class{constructor(t,e,r){this._collidedEntity=t;this._blocking=e;this._intersectInfo=r}get entity(){return this._collidedEntity}get blocking(){return this._blocking}get intersectInfo(){return this._intersectInfo}},N=class{static init(t){this._spatialInfo=t,this._collisionInfo=new Map,this._missInfo=new Map}static hasCollideInfo(t){return this._collisionInfo.has(t)}static getCollideInfo(t){return console.assert(this.hasCollideInfo(t)),this._collisionInfo.get(t)}static removeInfo(t){this._collisionInfo.delete(t)}static removeMissInfo(t){this._missInfo.delete(t)}static addMissInfo(t,e){this._missInfo.set(t,e)}static hasMissInfo(t){return this._missInfo.has(t)}static getMissInfo(t){return console.assert(this.hasMissInfo(t)),this._missInfo.get(t)}static detectInArea(t,e,r){let n=t.bounds,s=new P(n.width,0,0),i=new P(0,n.depth,0),o=new P(0,0,n.height),c=t.bounds.futureBounds(e),a=[n.minLocation,n.minLocation.add(o),n.minLocation.add(i),n.minLocation.add(s),n.maxLocation.sub(o),n.maxLocation.sub(i),n.maxLocation.sub(s),n.maxLocation],u=new Array,y=this._spatialInfo.getEntities(r);for(let b of y){if(b.id==t.id||!b.bounds.intersects(c))continue;if(b.geometry.cuboid&&t.geometry.cuboid){let d=new yt(b,!0,null);return this._collisionInfo.set(t,d),t.postEvent("collision"),d}let l=b.geometry;for(let p of a){let d=p.add(e),x=l.obstructsRay(p,d);if(x!=null){let S=new yt(b,!0,x);return this._collisionInfo.set(t,S),t.postEvent("collision"),S}else u.push(b),t.postEvent("noCollision")}}return this.addMissInfo(t,u),null}};v(N,"_collisionInfo"),v(N,"_missInfo"),v(N,"_spatialInfo");var X=class{static init(t,e){this._force=-t,this._context=e,this._enabled=!0}static update(t){if(this._enabled&&this._force<0){let e=new P(0,0,this._force);t.forEach(r=>{let n=r.bounds,s=new M(n.centre.add(e),n.dimensions);s.insert(n),N.detectInArea(r,e,s)==null&&r.updatePosition(e)})}}};v(X,"_enabled",!1),v(X,"_force",0),v(X,"_context");var ge=(r=>(r[r.Before=-1]="Before",r[r.Any=0]="Any",r[r.After=1]="After",r))(ge||{});function ft(h,t,e){return h>=t&&h<=e}var Ot=class{constructor(t,e){this._entity=t;e.setDrawOutline(this)}_succs=new Array;_min2D;_max2D;_top2D;_bottom2D;_drawCoord;updateOutline(t){this.min2D=this.min2D.add(t),this.max2D=this.max2D.add(t),this.top2D=this.top2D.add(t),this.bottom2D=this.bottom2D.add(t),this.drawCoord=this.drawCoord.add(t)}overlapDrawX(t){return ft(this.min2D.x,t.min2D.x,t.max2D.x)||ft(this.max2D.x,t.min2D.x,t.max2D.x)}overlapDrawY(t){return ft(this.top2D.y,t.top2D.y,t.bottom2D.y)||ft(this.bottom2D.y,t.top2D.y,t.bottom2D.y)}clear(){this._succs=[]}addSucc(t){this._succs.indexOf(t)==-1&&this._succs.push(t)}removeSucc(t){let e=this._succs.indexOf(t);e!=-1&&this._succs.splice(e,1)}get id(){return this._entity.id}get drawCoord(){return this._drawCoord}set drawCoord(t){this._drawCoord=t}get min2D(){return this._min2D}set min2D(t){this._min2D=t}get max2D(){return this._max2D}set max2D(t){this._max2D=t}get top2D(){return this._top2D}set top2D(t){this._top2D=t}get bottom2D(){return this._bottom2D}set bottom2D(t){this._bottom2D=t}get entity(){return this._entity}get succs(){return this._succs}get minZ(){return this._entity.bounds.minZ}get maxZ(){return this._entity.bounds.maxZ}},gt=class{_nodes=new Array;_order=new Array;_prevCameraLower=new _(0,0);_prevCameraUpper=new _(0,0);_dirty=!0;constructor(){}updateDrawOutline(t){let r=t.entity.bounds.minLocation,s=this.getDrawCoord(r).diff(t.min2D);t.updateOutline(s)}setDrawOutline(t){let e=t.entity,r=e.bounds.minLocation,n=e.bounds.maxLocation;t.min2D=this.getDrawCoord(r),t.max2D=this.getDrawCoord(n),t.top2D=this.getDrawCoord(new w(n.x,r.y,n.z)),t.bottom2D=this.getDrawCoord(new w(r.x,n.y,r.z));let s=t.min2D.diff(t.top2D),i=new _(t.min2D.x,t.min2D.y-s.y);t.drawCoord=i}get nodes(){return this._nodes}get order(){return this._order}set order(t){this._order=t}get dirty(){return this._dirty}set dirty(t){this._dirty=t}updateNode(t){this.updateDrawOutline(t),this.dirty=!0}insertNode(t){this.nodes.push(t),this.setDrawOutline(t),this.updateNode(t)}cameraHasMoved(t){let e=t.min,r=t.max,n=this._prevCameraLower.x!=e.x||this._prevCameraLower.y!=e.y||this._prevCameraUpper.x!=r.x||this._prevCameraUpper.y!=r.y;return this._prevCameraLower=e,this._prevCameraUpper=r,n}shouldDraw(t,e){let r=t.entity;if(r.visible&&r.drawable){let n=r.graphics[0].width,s=r.graphics[0].height;return e.isOnScreen(t.drawCoord,n,s)}else return!1}build(t,e){if(!e&&!this.dirty&&!t.hasMoved)return;let r=this.nodes.filter(i=>this.shouldDraw(i,t));r.sort((i,o)=>this.drawOrder(i,o)),r.forEach(i=>i.clear());for(let i=0;i<r.length;i++){let o=r[i];for(let c=i+1;c<r.length;++c){let a=r[c],u=this.drawOrder(o,a);u==-1?o.addSucc(a):u==1&&a.addSucc(o)}}this.order=[];let n=new Set,s=i=>{if(!n.has(i)){n.add(i);for(let o of i.succs)s(o);this.order.push(i)}};for(let i in r)s(r[i]);this.dirty=!1,t.hasMoved=!1}},et=class{constructor(t){this._graph=t}_nodes=new Map;_handler=new bt;get graph(){return this._graph}get nodes(){return this._nodes}get ctx(){return null}insertEntity(t){let e=new Ot(t,this.graph);this.nodes.set(e.id,e),this.graph.insertNode(e)}updateEntity(t){console.assert(this._nodes.has(t.id));let e=this._nodes.get(t.id);this.graph.updateNode(e)}getNode(t){return console.assert(this.nodes.has(t)),this.nodes.get(t)}getLocationAt(t,e,r){let n=this.getEntityDrawnAt(t,e,r);return n!=null?n.bounds.centre:null}getEntityDrawnAt(t,e,r){for(let n=0;n<this.graph.order.length;++n){let s=this.graph.order[n],i=s.entity;if(!i.visible||!i.drawable||!r.isOnScreen(s.drawCoord,i.width,i.depth))continue;let o=r.getDrawCoord(s.drawCoord),c=i.graphic;if(!(t<o.x||e<o.y||t>o.x+c.width||e>o.y+c.height)&&!c.isTransparentAt(t-o.x,e-o.y))return i}return null}addTimedEvent(t){this._handler.add(t)}render(t,e){this.graph.build(t,e);let n=this.graph.order.length*2*3*2,s=new ArrayBuffer(n),i=new Int16Array(s),o=0;for(let c=this.graph.order.length-1;c>=0;c--){let a=this.graph.order[c],u=a.entity,y=t.getDrawCoord(a.drawCoord);if(u.graphics.length*3+o>=i.length){let b=new ArrayBuffer(s.byteLength*2);new Int16Array(b).set(new Int16Array(s)),s=b,i=new Int16Array(s)}u.graphics.forEach(b=>{let l=b.update();i[o]=l,i[o+1]=y.x,i[o+2]=y.y,o+=3})}return this._handler.service(),new dt(i,o)}verifyRenderer(t){this.nodes.size!=t.length&&console.error("scene-level comparison between scene node and entities failed"),this.graph.nodes.length!=t.length&&console.error("graph-level comparison between scene node and entities failed");let e=0,r=new Array,n=new Array,s=new Array;for(let i of this.nodes.values())n.push(i.id);if(t.forEach(i=>s.push(i.id)),n.length!=s.length||n.length!=r.length)return console.error("number of scene nodes and entities don't match up"),!1;n.sort((i,o)=>i<o?-1:1),s.sort((i,o)=>i<o?-1:1),r.sort((i,o)=>i<o?-1:1);for(let i=0;i<n.length;++i){if(i!=n[i])return console.error("mismatch in expected ids:",i,n[i]),!1;if(n[i]!=s[i])return console.error("mismatch node vs entity ids:",n[i],s[i]),!1;if(n[i]!=r[i])return console.error("mismatch top level node vs found in level ids:",n[i],r[i]),!1}return!0}},ee=(e=>(e[e.TrueIsometric=0]="TrueIsometric",e[e.TwoByOneIsometric=1]="TwoByOneIsometric",e))(ee||{}),tt=class extends F{static physicalWidth(t){return Math.round(t*this._oneOverSqrt3)}static physicalDepth(t,e){let r=e.depth/e.width;return Math.round(t*r)}static physicalHeight(t,e){let r=e.height/e.width;return Math.round(t*r)}constructor(t,e){let r=tt.physicalWidth(t),n=tt.physicalDepth(r,e),s=tt.physicalHeight(r,e);super(r,n,s)}},zt=tt;v(zt,"_oneOverSqrt3",1/Math.sqrt(3));var Wt=class extends gt{constructor(){super()}static getDrawCoord(t){let e=Math.round(this._halfSqrt3*(t.x+t.y)),r=Math.round(.5*(t.y-t.x)-t.z);return new _(e,r)}getDrawCoord(t){return Wt.getDrawCoord(t)}drawOrder(t,e){return 0}},Q=Wt;v(Q,"_sqrt3",Math.sqrt(3)),v(Q,"_halfSqrt3",Math.sqrt(3)*.5);var _t=class extends gt{constructor(){super()}static getDrawCoord(t){let e=Math.floor((t.x+t.y)*2*this._oneOverMagicRatio),r=Math.floor((t.y-t.x-t.z)*this._oneOverMagicRatio);return new _(e,r)}static getDimensions(t,e){let r=t*.25,n=t*.5,s=r*this._magicRatio,i=s,o=(e-n)*this._magicRatio;return new F(Math.floor(s),Math.floor(i),Math.floor(o))}static drawOrder(t,e){return!t.entity.bounds.axisOverlapX(e.entity.bounds)&&!t.entity.bounds.axisOverlapY(e.entity.bounds)&&!t.entity.bounds.axisOverlapZ(e.entity.bounds)&&!t.overlapDrawX(e)&&!t.overlapDrawY(e)?0:t.entity.bounds.maxZ<=e.entity.bounds.minZ?-1:e.entity.bounds.maxZ<=t.entity.bounds.minZ?1:t.entity.bounds.maxY<=e.entity.bounds.minY?-1:e.entity.bounds.maxY<=t.entity.bounds.minY?1:t.entity.bounds.minX>=e.entity.bounds.maxX?-1:e.entity.bounds.minX>=t.entity.bounds.maxX?1:0}getDrawCoord(t){return _t.getDrawCoord(t)}drawOrder(t,e){return _t.drawOrder(t,e)}},Y=_t;v(Y,"_magicRatio",Math.cos(Math.atan(.5))),v(Y,"_oneOverMagicRatio",1/Math.cos(Math.atan(.5)));function re(h,t,e){switch(e){default:throw new Error("unsupported perspective");case 1:return Y.getDimensions(h,t)}}function ne(h){switch(h){default:throw new Error("unsupported perspective name");case"TrueIsometric":return 0;case"TwoByOneIsometric":return 1}}var xt=class{constructor(t,e,r){this._context=t;this._id=xt._ids,xt._ids++;let n=new w(e.x+r.width/2,e.y+r.depth/2,e.z+r.height/2),s=new M(n,r);this._geometry=new it(s),this._context.addEntity(this)}_id;_visible=!0;_drawable=!1;_geometry;_drawGeometry=!1;_handler=new Z;_graphicComponents=new Array;static reset(){this._ids=0}static getNumEntities(){return this._ids}get context(){return this._context}get geometry(){return this._geometry}get bounds(){return this._geometry.bounds}get dimensions(){return this.bounds.dimensions}get x(){return this.bounds.minX}get y(){return this.bounds.minY}get z(){return this.bounds.minZ}get width(){return this.bounds.width}get depth(){return this.bounds.depth}get height(){return this.bounds.height}get centre(){return this.bounds.centre}get id(){return this._id}get visible(){return this._visible}set visible(t){this._visible=t}get drawable(){return this._drawable}get drawGeometry(){return this._drawGeometry}get graphics(){return this._graphicComponents}get graphic(){return this._graphicComponents[0]}addGraphic(t){this._drawable=!0,this._graphicComponents.push(t)}updatePosition(t){this.bounds.update(t),this.geometry.transform(t)}addEventListener(t,e){this._handler.addEventListener(t,e)}removeEventListener(t,e){this._handler.removeEventListener(t,e)}postEvent(t){this._handler.post(t)}update(){this._handler.service()}},G=xt;v(G,"_ids",0);var Bt=class extends G{_lift=0;_canSwim=!1;_direction;constructor(t,e,r,n){super(t,e,r),this.addGraphic(n),t.addMovableEntity(this)}updatePosition(t){this.bounds.update(t),this.geometry.transform(t),this.postEvent("moving")}get lift(){return this._lift}get direction(){return this._direction}set direction(t){this._direction=t,this.postEvent("faceDirection")}},ie=class extends Bt{_action;constructor(t,e,r,n){super(t,e,r,n),t.addUpdateableEntity(this)}update(){super.update(),this._action!=null&&this._action.perform()&&(this._action=null)}set action(t){this._action=t}};function pr(h,t,e,r){let n=new G(h,t,e);return n.addGraphic(r),n}var Ut=(m=>(m[m.Flat=0]="Flat",m[m.Wall=1]="Wall",m[m.FlatWest=2]="FlatWest",m[m.FlatEast=3]="FlatEast",m[m.FlatNorthWest=4]="FlatNorthWest",m[m.FlatNorth=5]="FlatNorth",m[m.FlatNorthEast=6]="FlatNorthEast",m[m.FlatSouthWest=7]="FlatSouthWest",m[m.FlatSouth=8]="FlatSouth",m[m.FlatSouthEast=9]="FlatSouthEast",m[m.FlatNorthOut=10]="FlatNorthOut",m[m.FlatEastOut=11]="FlatEastOut",m[m.FlatWestOut=12]="FlatWestOut",m[m.FlatSouthOut=13]="FlatSouthOut",m[m.FlatAloneOut=14]="FlatAloneOut",m[m.FlatNorthSouth=15]="FlatNorthSouth",m[m.FlatEastWest=16]="FlatEastWest",m[m.RampUpSouthEdge=17]="RampUpSouthEdge",m[m.RampUpWestEdge=18]="RampUpWestEdge",m[m.RampUpEastEdge=19]="RampUpEastEdge",m[m.RampUpNorthEdge=20]="RampUpNorthEdge",m[m.RampUpSouth=21]="RampUpSouth",m[m.RampUpWest=22]="RampUpWest",m[m.RampUpEast=23]="RampUpEast",m[m.RampUpNorth=24]="RampUpNorth",m[m.Max=25]="Max",m))(Ut||{}),se=(p=>(p[p.Water=0]="Water",p[p.Inside=1]="Inside",p[p.Lowland0=2]="Lowland0",p[p.Lowland1=3]="Lowland1",p[p.Lowland2=4]="Lowland2",p[p.Lowland3=5]="Lowland3",p[p.Lowland4=6]="Lowland4",p[p.Lowland5=7]="Lowland5",p[p.Upland0=8]="Upland0",p[p.Upland1=9]="Upland1",p[p.Upland2=10]="Upland2",p[p.Upland3=11]="Upland3",p[p.Upland4=12]="Upland4",p[p.Upland5=13]="Upland5",p))(se||{}),H=class extends G{constructor(e,r,n,s,i){super(e,r,n);this._type=s;this._shape=i;if(this.addGraphic(H.graphics(s,i)),H.isFlat(i))this._tanTheta=0;else{let u=Math.atan(this.height/this.depth)*180/Math.PI;this._tanTheta=Math.tan(u)}this._shape==22?this._geometry=new st(this.geometry.bounds):this._shape==23?this._geometry=new ot(this.geometry.bounds):this._shape==21?this._geometry=new ht(this.geometry.bounds):this._shape==24&&(this._geometry=new at(this.geometry.bounds));let o=this.bounds.centre.x,c=this.bounds.centre.y,a=this.heightAt(this.bounds.centre);this._surfaceLocation=new w(o,c,a)}static reset(){this._terrainGraphics=new Map}static graphics(e,r){return this._terrainGraphics.has(e)?this._terrainGraphics.get(e).has(r)||console.error("missing graphics for TerrainShape:",H.getShapeName(r)):console.error("missing graphics for TerrainType:",H.getTypeName(e)),this._terrainGraphics.get(e).get(r)}static addGraphic(e,r,n,s,i,o,c){let a=z.create(n,s,i,o,c),u=new $(a);this._terrainGraphics.has(e)||this._terrainGraphics.set(e,new Map),this._terrainGraphics.get(e).set(r,u)}static async generateSprites(e,r){console.log("generateSprites"),await U.create(e.spriteSheetName,r).then(n=>{let s=e.spriteWidth,i=e.spriteHeight,o=e.tileColumnShapes.length,c=e.tileRowTypes.length;for(let a=0;a<c;++a){let u=e.tileRowTypes[a];for(let y=0;y<o;++y){let b=e.tileColumnShapes[y];this.addGraphic(u,b,n,s*y,i*a,s,i)}}})}static isSupportedType(e){return this._terrainGraphics.has(e)}static isSupportedShape(e,r){return this.isSupportedType(e)&&this._terrainGraphics.get(e).has(r)}static getShapeName(e){switch(e){default:return console.error("unhandled terrain shape:",e),"invalid shape";case 0:return"TerrainShape.Flat";case 1:return"TerrainShape.Wall";case 5:return"TerrainShape.FlatNorth";case 6:return"TerrainShape.FlatNorthRast";case 4:return"TerrainShape.FlatNorthWest";case 3:return"TerrainShape.FlatEast";case 2:return"TerrainShape.FlatWest";case 8:return"TerrainShape.FlatSouth";case 9:return"TerrainShape.FlatSouthEast";case 7:return"TerrainShape.FlatSouthWest";case 24:return"TerrainShape.RampUporth";case 20:return"TerrainShape.RampUpNorthEdge";case 23:return"TerrainShape.RampUpEast";case 19:return"TerrainShape.RampUpEastEdge";case 21:return"TerrainShape.RampUpSouth";case 17:return"TerrainShape.RampUpSouthEdge";case 22:return"TerrainShape.RampUpWest";case 18:return"TerrainShape.RampUpWestEdge";case 10:return"TerrainShape.FlatNorthOut";case 11:return"TerrainShape.FlatEastOut";case 12:return"TerrainShape.FlatWestOut";case 13:return"TerrainShape.FlatSouthOut";case 14:return"TerrainShape.FlatAloneOut";case 15:return"TerrainShape.FlatNorthSouth";case 16:return"TerrainShape.FlatEastWest"}}static getTypeName(e){switch(e){default:return console.error("unhandled terrain type:",e),"invalid terrain";case 0:return"TerrainType.Water";case 1:return"TerrainType.Inside";case 2:return"TerrainType.Lowland0";case 3:return"TerrainType.Lowland1";case 4:return"TerrainType.Lowland2";case 5:return"TerrainType.Lowland3";case 6:return"TerrainType.Lowland4";case 7:return"TerrainType.Lowland5";case 8:return"TerrainType.Upland0";case 9:return"TerrainType.Upland1";case 10:return"TerrainType.Upland2";case 11:return"TerrainType.Upland3";case 12:return"TerrainType.Upland4";case 13:return"TerrainType.Upland5"}}static isFlat(e){switch(e){default:break;case 4:case 5:case 6:case 15:case 2:case 0:case 1:case 3:case 16:case 7:case 8:case 9:case 10:case 11:case 13:case 12:case 14:return!0}return!1}static isEdge(e){switch(e){default:break;case 4:case 5:case 6:case 2:case 1:case 3:case 7:case 8:case 9:case 15:case 16:case 10:case 11:case 13:case 12:case 14:case 17:case 18:case 19:case 20:return!0}return!1}static isRamp(e){switch(e){default:break;case 17:case 18:case 19:case 20:case 21:case 22:case 23:case 24:return!0}return!1}static isRampUp(e,r){switch(r){default:break;case 0:return e==20||e==24;case 2:return e==19||e==23;case 4:return e==17||e==21;case 6:return e==18||e==22}return!1}_tanTheta;_surfaceLocation;get width(){return this.dimensions.width}get depth(){return this.dimensions.depth}get height(){return this.dimensions.height}get shape(){return this._shape}get type(){return this._type}get surfaceLocation(){return this._surfaceLocation}heightAt(e){return this.bounds.contains(e)?H.isFlat(this._shape)?this.z+this.height:this.z+e.y*this._tanTheta:null}},g=H;v(g,"_terrainGraphics",new Map);var wt=class{constructor(t,e,r,n,s,i,o){this._cellHeightGrid=t;this._typeGrid=e;this._shapeGrid=r;this._tileDimensions=n;this._cellsX=s;this._cellsY=i;this._cellsZ=o}get cellHeightGrid(){return this._cellHeightGrid}get typeGrid(){return this._typeGrid}get shapeGrid(){return this._shapeGrid}get tileDimensions(){return this._tileDimensions}get cellsX(){return this._cellsX}get cellsY(){return this._cellsY}get cellsZ(){return this._cellsZ}},Vt=class{_edgeCosts=new Map;_waypoint;constructor(t){this._waypoint=t.surfaceLocation}addNeighbour(t,e){this._edgeCosts.set(t,e)}hasNeighbour(t){return this._edgeCosts.has(t)}get neighbours(){return this._edgeCosts}get waypoint(){return this._waypoint}},vt=class{constructor(t,e){this._context=t;this._context.grid=this,this._cellsX=e.cellsX,this._cellsY=e.cellsY,this._dimensions=e.tileDimensions;for(let r=0;r<this.cellsY;++r){this.surfaceTerrain.push(new Array(this.cellsX));for(let n=0;n<this.cellsX;++n){let s=e.cellHeightGrid[r][n],i=e.shapeGrid[r][n],o=e.typeGrid[r][n],c=this.scaleGridToWorld(n,r,s),a=new g(this._context,c,this.dimensions,o,i);this._nodes.set(a,new Vt(a)),this.surfaceTerrain[r][n]=a,this._totalSurface++;let u=s-this.calcRelativeHeight(n,r,e),y=g.isFlat(i)?i:0;for(;s>u;){s--;let b=this.scaleGridToWorld(n,r,s);new g(this._context,b,this.dimensions,o,y),this._totalSubSurface++}}}for(let r=0;r<this.cellsY;r++)for(let n=0;n<this.cellsX;n++){let s=this.getSurfaceTerrainAt(n,r);this.addNeighbours(s)}}_surfaceTerrain=new Array;_cellsX;_cellsY;_dimensions;_totalSurface=0;_totalSubSurface=0;_nodes=new Map;get cellsX(){return this._cellsX}get cellsY(){return this._cellsY}get dimensions(){return this._dimensions}get totalSurface(){return this._totalSurface}get totalSubSurface(){return this._totalSubSurface}get surfaceTerrain(){return this._surfaceTerrain}get nodes(){return this._nodes}scaleGridToWorld(t,e,r){return new w(t*this.dimensions.width,e*this.dimensions.depth,r*this.dimensions.height)}scaleWorldToGrid(t){let e=this.dimensions.width,r=this.dimensions.depth,n=this.dimensions.height,s=t.x-t.x%e,i=t.y-t.y%r,o=t.z-t.z%n;return new w(Math.floor(s/e),Math.floor(i/r),Math.floor(o/n))}calcRelativeHeight(t,e,r){let n=0,s=r.cellHeightGrid[e][t];for(let i of E.neighbourOffsets.values()){let o=t+i.x,c=e+i.y;if(!this.inbounds(o,c))continue;let a=r.cellHeightGrid[c][o];console.assert(a>=0,"Found neighbour with negative terrace!",a);let u=s-a;n=Math.max(u,n)}return n}inbounds(t,e){return t>=0&&t<this.cellsX&&e>=0&&e<this.cellsY}getSurfaceTerrainAt(t,e){return this.inbounds(t,e)?this.surfaceTerrain[e][t]:null}getSurfaceLocationAt(t,e){return this.inbounds(t,e)?this.surfaceTerrain[e][t].surfaceLocation:null}getSurfaceTerrainAtPoint(t){let e=this.scaleWorldToGrid(t),r=this.getSurfaceTerrainAt(e.x,e.y);return r??null}addNeighbours(t){console.assert(this.nodes.has(t),"object not in node map: %o",t);let e=this.getAccessibleNeighbours(t);if(e.length==0)return;let r=this.nodes.get(t);for(let n of e){console.assert(this.nodes.has(n),"object not in node map: %o",n);let s=this.getNeighbourCost(t,n);r.addNeighbour(this.nodes.get(n),s)}}getNeighbourCost(t,e){let r=t.x==e.x||t.y==e.y?2:3;return g.isFlat(t.shape)&&g.isFlat(e.shape)||t.z==e.z?r:r*2}getAccessibleNeighbours(t){let e=new Map;for(let r of E.neighbourOffsets){let n=r[0],s=r[1],i=this.scaleWorldToGrid(t.surfaceLocation),o=this.getSurfaceTerrainAt(i.x+s.x,i.y+s.y);if(!o||Math.abs(t.z-o.z)>1)continue;let c=!0;switch(n){default:c=!1;break;case 7:if(!e.has(0)||!e.has(6))continue;break;case 1:if(!e.has(0)||!e.has(2))continue;break;case 3:if(!e.has(4)||!e.has(2))continue;break;case 5:if(!e.has(4)||!e.has(6))continue;break}let a=E.getOppositeDirection(n);if(o.z!=t.z)if(o.z>t.z&&!c){if(!g.isRampUp(o.shape,n))continue}else if(o.z<t.z&&!c){if(!g.isRampUp(o.shape,a))continue}else continue;e.set(n,o)}return Array.from(e.values())}findPath(t,e){let r=this.getSurfaceTerrainAtPoint(t),n=this.getSurfaceTerrainAtPoint(e);if(r==null||n==null)return new Array;let s=this.nodes.get(r);if(s.neighbours.size==0)return new Array;let i=this.nodes.get(n);if(i.neighbours.size==0)return new Array;let o=new mt,c=new Map,a=new Map;o.insert(s,0),c.set(s,null),a.set(s,0);let u=s;for(;!o.empty()&&(u=o.pop(),u!=i);)u.neighbours.forEach((b,l)=>{let p=a.get(u)+b;if(!a.has(l)||p<a.get(l)){a.set(l,p);let d=p;o.insert(l,d),c.set(l,u)}});if(u!=i)return Array();let y=new Array(u.waypoint);for(;u!=s;)u=c.get(u),y.push(u.waypoint);return y.reverse(),y.splice(1)}};var ae=(l=>(l[l.Water=0]="Water",l[l.Desert=1]="Desert",l[l.Grassland=2]="Grassland",l[l.Shrubland=3]="Shrubland",l[l.MoistForest=4]="MoistForest",l[l.WetForest=5]="WetForest",l[l.RainForest=6]="RainForest",l[l.Rock=7]="Rock",l[l.Tundra=8]="Tundra",l[l.AlpineGrassland=9]="AlpineGrassland",l[l.AlpineMeadow=10]="AlpineMeadow",l[l.AlpineForest=11]="AlpineForest",l[l.Taiga=12]="Taiga",l))(ae||{});function he(h){switch(h){default:return console.error("unhandled biome type:",h),"invalid biome";case 0:return"water";case 1:return"desert";case 2:return"grassland";case 3:return"shrubland";case 4:return"moist forest";case 5:return"wet forest";case 6:return"rain forest";case 8:return"tundra";case 9:return"alpine grassland";case 10:return"alpine meadow";case 11:return"alpine forest";case 12:return"taiga"}}var oe=class{constructor(t,e,r,n){this._waterLine=t;this._uplandThreshold=e;this._rainfall=r;this._rainDirection=n}get waterLine(){return this._waterLine}get uplandThreshold(){return this._uplandThreshold}get rainfall(){return this._rainfall}get rainDirection(){return this._rainDirection}};function ce(h,t,e){let r=t[0].length,n=t.length,s=6,i=new Array;for(let o=0;o<n;o++){i[o]=new Array;for(let c=0;c<r;c++){let a=0,u=e[o][c],y=Math.min(1,u/s),b=Math.floor(5*y),l=t[o][c];if(l<=h.waterLine)a=0;else if(l>=h.uplandThreshold)switch(b){default:console.error("unhandled moisture scale:",b);break;case 0:a=7;break;case 1:a=8;break;case 2:a=9;break;case 3:a=10;break;case 4:a=11;break;case 5:a=12;break}else switch(b){default:console.error("unhandled moisture scale:",b);break;case 0:a=1;break;case 1:a=2;break;case 2:a=3;break;case 3:a=4;break;case 4:a=5;break;case 5:a=6;break}i[o][c]=a}}return i}var Xt=class{constructor(t,e,r,n){this._pos=t;this._moisture=e;this._direction=r;this._rain=n}get x(){return this._pos.x}get y(){return this._pos.y}get pos(){return this._pos}set pos(t){this._pos=t}get moisture(){return this._moisture}set moisture(t){this._moisture=t}get rain(){return this._rain}get minHeight(){return this.rain.minHeight}get direction(){return this._direction}get moistureGrid(){return this.rain.moistureGrid}dropMoisture(t){let e=this.moisture*.1*t;this.moisture-=e,this.rain.addMoistureAt(this.pos,e)}terraceAt(t,e){return this.rain.terraceGrid[e][t]}heightAt(t,e){return this.rain.heightGrid[e][t]}inbounds(t){return t.x>=0&&t.x<this.rain.cellsX&&t.y>=0&&t.y<this.rain.cellsY}move(){for(;this.inbounds(this.pos);){let t=E.getAdjacentCoord(this.pos,this.direction);if(!this.inbounds(t)){this.dropMoisture(1);return}if(this.heightAt(this.x,this.y)<=this.minHeight||this.terraceAt(this.x,this.y)<1){this.pos=t;continue}let e=this.terraceAt(t.x,t.y)>this.terraceAt(this.x,this.y)?1.5:1;this.dropMoisture(e),this.pos=t}}},Yt=class{constructor(t,e,r,n,s,i,o){this._cellsX=t;this._cellsY=e;this._heightGrid=r;this._terraceGrid=n;this._minHeight=s;for(let c=0;c<this.cellsY;c++)this._moistureGrid.push(new Array(this.cellsX).fill(0));switch(o){default:console.error("unhandled direction");break;case 0:{let c=this.cellsY-1;for(let a=0;a<this.cellsX;a++)this.addCloud(new _(a,c),i,o);break}case 2:{for(let a=0;a<this.cellsY;a++)this.addCloud(new _(0,a),i,o);break}case 4:{for(let a=0;a<this.cellsX;a++)this.addCloud(new _(a,0),i,o);break}case 6:{let c=this.cellsX-1;for(let a=0;a<this.cellsY;a++)this.addCloud(new _(c,a),i,o);break}}}_clouds=Array();_totalClouds=0;_moistureGrid=new Array;get cellsX(){return this._cellsX}get cellsY(){return this._cellsY}get clouds(){return this._clouds}get totalClouds(){return this._totalClouds}get minHeight(){return this._minHeight}get moistureGrid(){return this._moistureGrid}get heightGrid(){return this._heightGrid}get terraceGrid(){return this._terraceGrid}moistureAt(t,e){return this._moistureGrid[e][t]}addMoistureAt(t,e){this.moistureGrid[t.y][t.x]+=e}addCloud(t,e,r){this.clouds.push(new Xt(t,e,r,this)),this._totalClouds++}run(){for(;this.clouds.length!=0;){let t=this.clouds[this.clouds.length-1];this.clouds.pop(),t.move()}}};function _e(h){let t=0,e=0;for(let r of h){let n=r.reduce(function(s,i){return s+i},0);t+=n,e+=r.length}return t/e}function xe(h,t,e,r){let n=0,s=r.length*r.length;for(let i in r){let o=e+r[i];for(let c in r){let a=t+r[c];n+=h[o][a]}}return n/s}function we(h,t,e,r){let n=xe(h,t,e,r);if(n==0)return 0;let s=new Array,i=r.length;for(let o in r){let c=e+r[o],a=new Array(i),u=0;for(let y in r){let b=t+r[y],l=h[c][b]-n;a[u]=l*l,u++}s.push(a)}return Math.sqrt(_e(s))}function ve(h,t,e){let n=Math.floor(2.5),s=[-2,-1,0,1,2],i=[4,1,0,1,4],o=new Array;for(let a=0;a<n;a++)o[a]=h[a];for(let a=e-n;a<e;a++)o[a]=h[a];let c=new Array(5);for(let a=n;a<e-n;a++){o[a]=new Array(t);for(let u=0;u<n;u++)o[a][u]=h[a][u];for(let u=t-n;u<t;u++)o[a][u]=h[a][u];for(let u=n;u<t-n;u++){let y=we(h,u,a,s);if(y==0)continue;let b=y*y,l=Math.sqrt(2*Math.PI*b),p=0;for(let x in i){let D=Math.exp(-(i[x]/(2*b)));c[x]=D/l,p+=c[x]}for(let x of c)x/=p;let d=0;for(let x in s){let D=s[x];d+=h[a][u+D]*c[x]}for(let x in s){let D=s[x];d+=h[a+D][u]*c[x]}o[a][u]=d}}return o}function ue(h,t,e,r,n){let s=h[0].length,i=h.length,o=new Yt(s,i,h,t,n,r,e);return o.run(),ve(o.moistureGrid,s,i)}function De(h,t,e,r){return h.rainfall>0&&(t=ue(e,r,h.rainDirection,h.rainfall,h.waterLine)),ce(h,e,t)}function Se(h,t){let e=0,r=0;for(let s=0;s<h.length;s++){let i=h[s],o=i.reduce(function(a,u){return Math.max(a,u)}),c=i.reduce(function(a,u){return Math.min(a,u)});e=Math.min(e,c),r=Math.max(r,o)}if(e<0){e=Math.abs(e);let s=h.length,i=h[0].length;for(let o=0;o<s;o++)for(let c=0;c<i;c++)h[o][c]+=e;r+=e}return r/t}function Ae(h,t){let e=h.length,r=h[0].length,n=new Array;for(let s=0;s<e;s++){n[s]=new Array;for(let i=0;i<r;i++){let o=h[s][i];n[s][i]=Math.floor(o/t)}}return n}var Dt=class{constructor(t,e,r,n,s){this._heightGrid=t;this._numTerraces=e;this._floor=r;this._wall=n;this._tileDimensions=s;this._depth=this.heightGrid.length,this._width=this.heightGrid[0].length,this._terraceSpacing=Se(this.heightGrid,this.numTerraces),this._terraceGrid=Ae(this.heightGrid,this.terraceSpacing);for(let i=0;i<this.depth;i++){this._moistureGrid[i]=new Array,this._shapeGrid[i]=new Array,this._typeGrid[i]=new Array;for(let o=0;o<this.width;o++)this.shapeGrid[i][o]=0,this.typeGrid[i][o]=this.floor}}_terraceSpacing;_depth;_width;_biomeGrid=new Array;_terraceGrid=new Array;_moistureGrid=new Array;_typeGrid=new Array;_shapeGrid=new Array;get numTerraces(){return this._numTerraces}get wall(){return this._wall}get floor(){return this._floor}get tileDimensions(){return this._tileDimensions}get terraceSpacing(){return this._terraceSpacing}get width(){return this._width}get depth(){return this._depth}get heightGrid(){return this._heightGrid}get moistureGrid(){return this._moistureGrid}get terraceGrid(){return this._terraceGrid}get shapeGrid(){return this._shapeGrid}get typeGrid(){return this._typeGrid}get biomeGrid(){return this._biomeGrid}terraceAt(t,e){return console.assert(t>=0&&t<this.width&&e>=0&&e<this.depth),this._terraceGrid[e][t]}terrainTypeAt(t,e){return console.assert(t>=0&&t<this.width&&e>=0&&e<this.depth),this._typeGrid[e][t]}terrainShapeAt(t,e){return console.assert(t>=0&&t<this.width&&e>=0&&e<this.depth),this._shapeGrid[e][t]}moistureAt(t,e){return console.assert(t>=0&&t<this.width&&e>=0&&e<this.depth),this._moistureGrid[e][t]}isFlatAt(t,e){return console.assert(t>=0&&t<this.width&&e>=0&&e<this.depth),g.isFlat(this._shapeGrid[e][t])}biomeAt(t,e){return console.assert(t>=0&&t<this.width&&e>=0&&e<this.depth),this._biomeGrid[e][t]}heightAt(t,e){return console.assert(t>=0&&t<this.width&&e>=0&&e<this.depth),this._heightGrid[e][t]}generateBiomes(t){this._biomeGrid=De(t,this.moistureGrid,this.heightGrid,this.terraceGrid),Pe(this.biomeGrid,this.typeGrid)}generateMap(t){Te(this._heightGrid,this._terraceGrid,this._shapeGrid,this._terraceSpacing,0),Ee(this._terraceGrid,this._shapeGrid,this._typeGrid,this.floor,this.wall,this.wall!=this.floor);let e=new wt(this.terraceGrid,this.typeGrid,this.shapeGrid,this.tileDimensions,this.width,this.depth,this.numTerraces);new vt(t,e)}};function Te(h,t,e,r,n){let s=[new _(0,1),new _(-1,0),new _(0,-1),new _(1,0)],i=[21,22,24,23],o=h.length,c=h[0].length,a=function(b,l,p){let d=b+p/2,x=d-n,D=d+n,S=(l+1)*p;return S>=x&&S<=D},u=0,y=new Map;for(let b=o-3;b>1;b--)for(let l=2;l<c-2;l++){let p=e[b][l];if(!g.isFlat(p))continue;let d=h[b][l],x=t[b][l];if(a(d,x,r))for(let D in s){let S=s[D],A=l+S.x,W=b+S.y;if(y.has(A)&&y.get(A).has(W))continue;let R=A+S.x,I=W+S.y;if(y.has(R)&&y.get(R).has(I))continue;let k=t[W][A],J=t[I][R];k==x+1&&k==J&&(e[W][A]=i[D],y.has(A)?y.get(A).add(W):y.set(A,new Set([W])),y.has(R)?y.get(R).add(I):y.set(R,new Set([I])),u++)}}return u}function Ee(h,t,e,r,n,s){let i=h.length,o=h[0].length,c=function(a,u){return a>=0&&a<o&&u>=0&&u<i};for(let a=0;a<i;a++)for(let u=0;u<o;u++){if(e[a][u]==0)continue;let y=new _(u,a),b=h[a][u],l=t[a][u],p=e[a][u],d=t[a][u],x=!1,D=!1,S=!1,A=!1,W=u==0||u==o-1||a==0||a==i-1;for(let R of E.neighbourOffsets.values()){let I=u+R.x,k=a+R.y;if(!c(I,k))continue;let J=new _(I,k),Ht=h[k][I],m=t[k][I];if(!(Ht>b)&&!(J.x!=u&&J.y!=a)&&!(Ht==b&&g.isFlat(l)==g.isFlat(m))){if(!g.isFlat(m))switch(E.getDirectionFromPoints(J,y)){default:break;case 0:if(m==24)continue;break;case 2:if(m==23)continue;break;case 4:if(m==21)continue;break;case 6:if(m==22)continue;break}if(x=x||k<a,S=S||k>a,D=D||I>u,A=A||I<u,x&&D&&S&&A)break}}if(d==0?x&&D&&S&&A?d=14:x&&D&&A?d=10:x&&D&&S?d=11:D&&S&&A?d=13:S&&A&&x?d=12:x&&D?d=6:x&&A?d=4:S&&D?d=9:S&&A?d=7:S&&x?d=15:D&&A?d=16:x?d=5:S?d=8:D?d=3:A&&(d=2):d==24&&D?g.isSupportedShape(p,20)&&(d=20):d==23&&x?g.isSupportedShape(p,19)&&(d=19):d==21&&D?g.isSupportedShape(p,17)&&(d=17):d==22&&x&&g.isSupportedShape(p,18)&&(d=18),d==0&&W&&(u==0&&a==0?d=4:u==0&&a==i-1?d=7:u==o-1&&a==0?d=6:u==0?d=2:a==0?d=5:u==o-1&&a==i-1?d=9:u==o-1?d=3:a==i-1&&(d=8)),g.isFlat(d)&&g.isEdge(d)&&(s&&(p=n),!g.isSupportedShape(p,d)))switch(d){default:d=1;break;case 10:g.isSupportedShape(p,5)?d=5:d=1;break;case 6:case 9:g.isSupportedShape(p,3)?d=3:d=1;break;case 4:g.isSupportedShape(p,12)?d=12:d=1;break;case 7:g.isSupportedShape(p,2)?d=2:d=1;break}b==0&&d==1&&(d=0),!g.isFlat(d)&&!g.isSupportedShape(p,d)&&(g.isSupportedShape(r,d)?p=r:g.isSupportedShape(n,d)&&(p=n)),g.isSupportedShape(p,d)||(d=0),e[a][u]=p,t[a][u]=d}}function Pe(h,t){let e=h.length,r=h[0].length;for(let n=0;n<e;n++)for(let s=0;s<r;s++){let i=h[n][s],o=0;switch(i){default:console.error("unhandled biome:",he(i));break;case 0:break;case 7:o=8;break;case 8:o=9;break;case 9:o=10;break;case 10:o=11;break;case 11:o=12;break;case 12:o=13;break;case 1:o=2;break;case 2:o=3;break;case 3:o=4;break;case 4:o=5;break;case 5:o=6;break;case 6:o=7;break}g.isSupportedType(o)?t[n][s]=o:console.log("unsupported biome terrain type:",g.getTypeName(o))}}var Tt=class{constructor(t){this._bounds=t}_children=new Array;_entities=new Array;get children(){return this._children}get entities(){return this._entities}get bounds(){return this._bounds}get centre(){return this._bounds.centre}get width(){return this._bounds.width}get height(){return this._bounds.height}get depth(){return this._bounds.depth}get recursiveCountNumEntities(){if(this.entities.length!=0)return this.entities.length;let t=0;for(let e of this.children)t+=e.recursiveCountNumEntities;return t}insert(t){let e=!1;if(this.children.length==0)this.entities.push(t),this.bounds.insert(t.bounds),this.entities.length>Tt.MaxEntities?e=this.split():e=!0;else{for(let r of this.children)if(r.bounds.containsBounds(t.bounds)){e=r.insert(t);break}if(!e){for(let r of this.children)if(r.containsLocation(t.centre)){e=r.insert(t);break}}}return console.assert(e,"failed to insert entity into octree node"),e}split(){this._children=new Array;let t=this.bounds.width/2,e=this.bounds.depth/2,r=this.bounds.height/2,n=new F(t,e,r),s=[-.5,.5];for(let o=0;o<2;o++)for(let c=0;c<2;c++)for(let a=0;a<2;a++){let u=s[a]*n.width,y=s[c]*n.depth,b=s[o]*n.height,l=new w(this.centre.x+u,this.centre.y+y,this.centre.z+b),p=new M(l,n);this.children.push(new Tt(p))}let i=function(o,c){return o.containsLocation(c.bounds.centre)?o.insert(c):!1};for(let o of this._entities){let c=!1;for(let a of this._children)if(i(a,o)){c=!0;break}console.assert(c,"failed to insert into children, entity centred at:",o.bounds.centre)}return this._entities=[],!0}containsBounds(t){return this.bounds.containsBounds(t)}containsLocation(t){return this.bounds.contains(t)}containsEntity(t){return this.entities.indexOf(t)!=-1}recursivelyContainsEntity(t){if(this.containsEntity(t))return!0;for(let e of this._children)if(e.recursivelyContainsEntity(t))return!0;return!1}recursiveRemoveEntity(t){let e=this.entities.indexOf(t);if(e!=-1)return this.entities.splice(e,1),!0;for(let r of this.children)if(r.recursiveRemoveEntity(t))return!0;return!1}},St=Tt;v(St,"MaxEntities",30);var At=class{_root;_numEntities=0;_worldBounds;constructor(t){let e=t.width/2,r=t.depth/2,n=t.height/2,s=new w(e,r,n);this._worldBounds=new M(s,t),this._root=new St(this._worldBounds)}get root(){return this._root}get bounds(){return this.root.bounds}insert(t){let e=this._root.insert(t);console.assert(e,"failed to insert"),this._numEntities++}findEntitiesInArea(t,e,r){if(t.entities.length!=0)t.entities.forEach(n=>r.push(n));else for(let n of t.children)n.bounds.intersects(e)&&this.findEntitiesInArea(n,e,r)}getEntities(t){let e=new Array;return this.findEntitiesInArea(this.root,t,e),e}update(t){let e=this.root.recursiveRemoveEntity(t);console.assert(e),this._numEntities--,this.insert(t)}verify(t){for(let e of t)if(!this._root.recursivelyContainsEntity(e))return console.error("tree doesn't contain entity at (x,y,z):",e.x,e.y,e.z),!1;return!0}};var K=class{_scene;_renderer;_entities=new Array;_updateables=new Array;_movables=new Array;_controllers=new Array;_spatialGraph;_totalEntities=0;_grid;static reset(){G.reset(),g.reset(),U.reset()}constructor(t,e){switch(this._spatialGraph=new At(t),N.init(this._spatialGraph),e){default:console.error("unhandled perspective");break;case 0:this._scene=new et(new Q);break;case 1:this._scene=new et(new Y);break}this._renderer=new lt}get scene(){return this._scene}get renderer(){return this._renderer}get entities(){return this._entities}get bounds(){return this._spatialGraph.bounds}get spatial(){return this._spatialGraph}get controllers(){return this._controllers}set grid(t){this._grid=t}get grid(){return this._grid}verify(){return this.entities.length==G.getNumEntities()&&this.entities.length==this._totalEntities&&this.spatial.verify(this.entities)&&this.scene.verifyRenderer(this.entities)}addOnscreenRenderer(t){this._renderer=new pt(t)}addController(t){this._controllers.push(t)}addEntity(t){this.entities.length==0?t.id!=0&&console.error("Adding entity with unexpected id:",t.id):this.entities.length>0&&t.id!=this.entities[this.entities.length-1].id+1&&console.error("Adding entity with unexpected id:",t.id),this.entities.push(t),this.spatial.insert(t),this.scene.insertEntity(t),this._totalEntities++}addUpdateableEntity(t){this._updateables.push(t)}addMovableEntity(t){this._movables.push(t),t.addEventListener("moving",()=>{this.spatial.update(t),this.scene.updateEntity(t)})}update(t){t.update();let e=this._scene.render(t,!1);this.renderer.draw(e),X.update(this._movables),this._updateables.forEach(r=>{r.update()}),this._controllers.forEach(r=>{r.update()})}};function Ce(h,t,e){K.reset();let r=new K(t,e);return r.addOnscreenRenderer(h),r}function an(h,t){return K.reset(),new K(h,t)}async function hn(h){let t=h.terrainSpriteDescriptor,e=t.spriteWidth,r=t.spriteHeight,n=ne(h.projection),s=re(e,r,n),i=h.heightMap.length,o=h.heightMap[0].length,c=1+h.numTerraces,a=new F(s.width*o,s.depth*i,s.height*c),u=document.getElementById(h.canvasName),y=Ce(u,a,n);return await g.generateSprites(t,y).then(()=>{let b=new Dt(h.heightMap,h.numTerraces,h.floor,h.wall,s);Object.hasOwn(h,"biomeConfig")&&b.generateBiomes(h.biomeConfig),b.generateMap(y)}),y}var Et=class{constructor(t,e,r){this._scene=t;this._width=Math.floor(e),this._height=Math.floor(r),this._upperX=Math.floor(e),this._upperY=Math.floor(r),this._surfaceLocation=t.getLocationAt(this._lowerX,this._lowerY,this)}_lowerX=0;_lowerY=0;_upperX;_upperY;_width;_height;_handler=new Z;_surfaceLocation;_hasMoved=!0;isOnScreen(t,e,r){return!(t.x+e<this._lowerX||t.y+r<this._lowerY||t.x-e>this._upperX||t.y-r>this._upperY)}get hasMoved(){return this._hasMoved}set hasMoved(t){this._hasMoved=t}get min(){return new _(this._lowerX,this._lowerY)}get max(){return new _(this._upperX,this._upperY)}get width(){return this._width}get height(){return this._height}get location(){return this._surfaceLocation}set location(t){if(t==null){console.log("undefined camera surface location");return}let e=this._scene.graph.getDrawCoord(t);this.x=e.x,this.y=e.y,this._handler.post("cameraMove"),this._surfaceLocation=t}set x(t){this._lowerX=t-Math.floor(this.width/2),this._upperX=t+Math.floor(this.width/2)}set y(t){this._lowerY=t-Math.floor(this.height/2),this._upperY=t+Math.floor(this.height/2)}getDrawCoord(t){return new _(t.x-this._lowerX,t.y-this._lowerY)}update(){this._handler.service()}addEventListener(t,e){this._handler.addEventListener(t,e)}removeEventListener(t,e){this._handler.removeEventListener(t,e)}},de=class extends Et{constructor(t,e,r,n){super(t,r,n),e.addEventListener("mousedown",s=>{s.button==0&&(this.location=t.getLocationAt(s.offsetX,s.offsetY,this),this.hasMoved=!0)}),e.addEventListener("touchstart",s=>{let i=s.touches[0];this.location=t.getLocationAt(i.pageX,i.pageY,this),this.hasMoved=!0})}},le=class extends Et{constructor(t,e,r,n){super(t,e,r),this.location=n.centre,n.addEventListener("moving",()=>{this.location=n.centre,this.hasMoved=!0})}};var Pt=class{constructor(t){this._actor=t}get actor(){return this._actor}set actor(t){this._actor=t}},Ct=class extends Pt{constructor(t){super(t)}obstructed(t,e){let r=this._actor.bounds,n=e.vec_diff(t),s=new M(e,r.dimensions);return s.insert(r),N.detectInArea(this._actor,n,s)}perform(){return!0}},pe=class extends Ct{constructor(e,r,n){super(e);this._d=r;this._bounds=n}perform(){let e=this.actor.bounds.bottomCentre,r=e.add(this._d),n=this.obstructed(e,r);return n==null?(this.actor.updatePosition(this._d),!1):n.blocking?(this.actor.postEvent("endMove"),!0):(console.log("adjusting movement with max angle"),this.actor.updatePosition(this._d),!1)}},Lt=class extends Ct{constructor(e,r,n){super(e);this._step=r;this._destination=n;this.destination=n}_d;set speed(e){this._step=e}get destination(){return this._destination}get d(){return this._d}set destination(e){this._destination=e;let r=this.actor.bounds.bottomCentre;this._d=e.vec_diff(r).norm().mulScalar(this._step);let n=E.getDirectionFromVector(new C(this._d.x,this._d.y));this.actor.direction=n}perform(){let r=this.actor.bounds.bottomCentre;return this.obstructed(r,r.add(this._d))||this.destination.vec_diff(r).mag()<this._step?!0:(this.actor.updatePosition(this._d),this.actor.postEvent("moving"),!1)}},Mt=class extends Pt{constructor(e,r,n){super(e);this._step=r;this._destination=n;this._waypoints=e.context.grid.findPath(e.bounds.bottomCentre,n),this.waypoints.length!=0&&(this._currentStep=new Lt(e,this.step,this.waypoints[0]))}_currentStep;_waypoints;_index=0;get step(){return this._step}get index(){return this._index}get waypoints(){return this._waypoints}perform(){if(this.waypoints.length==0)return!0;if(!this._currentStep.perform())return!1;if(this._index++,this.index==this.waypoints.length)return!0;let r=this.waypoints[this.index];return this._currentStep=new Lt(this._actor,this.step,r),!1}};function wn(h,t,e,r,n){console.assert(h.grid&&"expected grid"),t.addEventListener("mousedown",s=>{if(s.button==0){console.log("mouse click");let i=h.scene.getLocationAt(s.offsetX,s.offsetY,e);i&&(r.action=new Mt(r,n,i))}}),t.addEventListener("touchstart",s=>{let i=s.touches[0],o=h.scene.getLocationAt(i.pageX,i.pageY,e);o&&(r.action=new Mt(r,n,o))})}var It=class{_id;_track;static pause(t){this._tracks[t].pause()}static play(t,e){e>this._maxVolume&&(e=this._maxVolume);let r=this._tracks[t];console.log("play music at:",e),r.volume=e,r.playing||r.play()}constructor(t,e){this._id=It._tracks.length,this._track=new Audio(t),console.assert(this._track!=null,"failed to create audio"),this._track.loop=e,It._tracks.push(this)}set volume(t){this._track.volume=t}get playing(){return!this._track.paused&&this._track.currentTime!=0}pause(){this._track.pause()}play(){this._track.play()}},O=It;v(O,"_tracks",new Array),v(O,"_maxVolume",.8);var me=class extends O{constructor(t,e,r){super(t,!0);let n=this._id,s=Math.sqrt(Math.pow(e.maxX-e.minX,2)+Math.pow(e.maxY-e.minY,2)+Math.pow(e.maxZ-e.minZ,2))/2;console.log("centre of audio zone (x,y):",e.centre.x,e.centre.y),console.log("max distance from centre:",s);let i=function(){let o=r.location;if(o==null){console.log("couldn't get camera location");return}if(!e.contains(r.location)){console.log("camera location not inbounds"),O.pause(n);return}let c=o.x-e.centre.x,a=o.y-e.centre.y;c=Math.abs(c/s),a=Math.abs(a/s);let u=O._maxVolume*Math.exp(-8*(c+a));O.play(n,u)};r.addEventListener("cameraMove",i),window.addEventListener("focus",i),window.addEventListener("blur",()=>{O.pause(n)})}};export{Pt as Action,ie as Actor,Jt as AnimatedDirectionalGraphicComponent,ct as AnimatedGraphicComponent,ae as Biome,oe as BiomeConfig,M as BoundingCuboid,Et as Camera,N as CollisionDetector,yt as CollisionInfo,K as ContextImpl,it as CuboidGeometry,F as Dimensions,j as Direction,Ft as DirectionalGraphicComponent,Zt as DrawElement,dt as DrawElementList,qt as DummyGraphicComponent,lt as DummyRenderer,We as DummySpriteSheet,q as EntityEvent,Z as EventHandler,nt as Face3D,B as Geometry,V as GraphicComponent,$t as GraphicEvent,X as Gravity,kt as InputEvent,Nt as IntersectInfo,zt as IsometricPhysicalDimensions,Kt as LoopGraphicComponent,mt as MinPriorityQueue,de as MouseCamera,Bt as MovableEntity,Lt as MoveDestination,pe as MoveDirection,Mt as Navigate,E as Navigation,jt as NoGeometry,te as OffscreenRenderer,pt as OnscreenRenderer,fe as Orientation,Qt as OssilateGraphicComponent,ee as Perspective,G as PhysicalEntity,_ as Point2D,w as Point3D,T as QuadFace3D,Yt as Rain,ot as RampUpEastGeometry,at as RampUpNorthGeometry,ht as RampUpSouthGeometry,st as RampUpWestGeometry,ge as RenderOrder,et as Scene,gt as SceneGraph,Ot as SceneNode,rt as Segment2D,O as Sound,z as Sprite,U as SpriteSheet,$ as StaticGraphicComponent,g as Terrain,Dt as TerrainBuilder,vt as TerrainGrid,wt as TerrainGridDescriptorImpl,Ut as TerrainShape,se as TerrainType,bt as TimedEventHandler,wn as TouchOrClickNav,le as TrackerCamera,Q as TrueIsometric,Y as TwoByOneIsometric,C as Vector2D,P as Vector3D,f as Vertex3D,me as ZonalAudioLoop,ue as addRain,Ce as createContext,Be as createDirectionalGraphics,pr as createGraphicalEntity,an as createTestContext,hn as createWorld,ce as generateBiomeGrid,he as getBiomeName,re as getDimensionsFromPerspective,ne as getPerspectiveFromString,Se as normaliseHeightGrid,Ee as setEdges,Te as setRamps,Ae as setTerraces,Pe as setTerrainTypes};
